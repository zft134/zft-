# 操作系统复习指南

本指南根据2025版王道操作系统编写，并且补充了一些比较容易考察到的知识点，知识点并不全，只是收录一些容易遗漏的知识点

## 计算机系统概述

### 用户态切换到内核态

1）用户程序要求重装系统的服务，即<font color=red>**系统调用**</font>

2）发生一次<font color=red>**中断**</font>

3）用户态中产生了一个<font color=red>**错误状态**</font>

4）用户程序中企图执行一条<font color=red>**特权指令**</font>

### 内核态切换到用户态

从内核态转向用户态由一条指令实现，这条指令也是<font color=red>**特权指令**</font>，一般是<font color=red>**中断返回指令**</font>

## 进程与线程

操作系统的**最基本特性**是<font color=red>**并发性**</font>和<font color=red>**共享性**</font>

### 进程的组成

进程是一个独立的运行单位，也是操作系统进行**资源分配**和**调度**的**基本单位**。它由以下三部分组成，其中最核心的是**进程控制块**（PCB）

**进程实体**由<font color=red>**程序段**</font>、<font color=red>**相关数据段**</font>和<font color=red>**PCB**</font>组成

### 进程状态

#### 区分

##### 挂起

将数据结构从内存搬移到**磁盘**，等待某些条件满足后可以被重新恢复。这通常出现在需要腾出内存资源或者某些条件暂时不满足时

##### 阻塞

等待时间发生 任务在内存。当进程在**某些外部事件（如I/O操作完成、锁释放）**时，进入阻塞状态。这个状态下，进程无法继续执行，操作系统将不会为其分配CPU时间

##### 运行

当进程获得CPU资源，并且正在执行其指令时，它处于运行状态。操作系统将进程调度到CPU上，运行它执行任务

##### 就绪

当一个进程已经具**备执行的所有条件**，但尚未获得CPU时，它就处于就绪态。这意味着它准备好执行，但操作系统还没有为其分配CPU（<font color=red>**就绪态只缺一个CPU**</font>）

#### 三状态模型

##### 运行态

此状态表明进程当前正实际占用CPU的时间片进行执行。

##### 就绪态

就绪态的进程已准备好执行，但由于CPU资源正被其他进程占用， 因此它暂时处于等待CPU时间片的状态。

##### 阻塞态

阻塞态的进程因等待某个外部事件（如I/O操作完成、信号量释 放等）而无法继续执行。除非该事件发生，否则即使CPU空闲，该进程也无法运行。

![image-20241014222051582](assets/image-20241014222051582.png)

### 线程

**优势**

主要优势在于它们能够**共享同一地址块**。这意味着线程可以直接访问进程中的全局变量、静态变量以及通过指针或引用访问的区域，而无需进行进程间通信（IPC）的复杂操作

### 进程和线程的主要区别

#### 资源分配

**进程**：是操作系统资源分配的基本单位，每个进程有独立的内存空间和资源

**线程**：是进程内的执行单位，多个线程共享进程的资源（如内存、文件句柄等）

#### 开销

**进程**：常见和切换的开销大，因为每个进程都有独立的资源和内存

**线程**：开销小，线程间切换更快，因为它们共享进程

#### 内存空间

**进程**：进程之间有独立的内存空间，不能直接共享数据

**线程**：同一进程的线程共享内存空间，可以直接共享数据

#### 通信方式

**进程**:进程之间的通信需要使用复杂的进程间通信（IPC）机制

**线程**：线程之间通信简单，因为它们共享相同的地址空间

### CPU调度

#### 高级调度（作业调度）

按照某种规则从外存上处于后备队列的作业中挑选一个（或多个），给它（们）分配内存、I/O设备等必要的资源，并建立相应的进程，以使它（们）获得竞争CPU的权利。

负责从<font color=red>**创建态**</font>转换到<font color=red>**就绪态**</font>

#### 中级调度（内存调度）

引入中级调度的目的是<font color=red>**提高内存利用率和系统吞吐量**</font>。为此，将那些暂时不能运行的进程调至外存等待，此时进程的状态称为**挂起态**。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定将外存上的那些已经具备运行条件的挂起进程再重新调入内存，并修改为**就绪态**，挂在就绪队列上等待。中级调度实际上是<font color=red>**存储器管理中的对换功能**</font >。

#### **低级调度（进程调度）**

按照某种算法从就绪队列中选取一个进程，将CPU分配给它。进程调度是<font color=red>**最基本**</font>的一种调度，在各种操作系统中都必须配置这级调度。进程调度的频率很高，一般几十毫秒一次

### 进程互斥

对于临界资源的互斥访问，可以在逻辑上分为如下四个部分

```c++
do{
    enrty section	// 进入区
    critical section	// 临界区  访问临界资源的那段代码
    exit section	// 退出区
   	remainder section	// 剩余区
} while(true)
```

**注意**：
<font color=red>**临界区**</font>是进程中<font color=red>**访问临界资源**</font>的代码段

<font color=red>**进入区**</font>和<font color=red>**退出区**</font>是<font color=red>**负责实现互斥**</font>的代码段

### 死锁

#### 预防死锁

##### 破坏性条件

将临界资源改造为可共享使用的资源（如SPOOLing资源）

**缺点**：可行性不高，很多时候无法破坏互斥条件

##### 破坏不剥夺条件

**方案一**，申请的资源得不到满足时，立即释放拥有的所有资源（<font color=red>**主动释放**</font>）

**方案二**，申请的资源被其他进程占用时，有操作系统协助剥夺（考虑优先级）

##### 破坏请求和保持条件

运行前分配好所有需要的资源，之后一直保持

**缺点**：资源利用率低；可能导致饥饿

##### 破坏循环等待条件

给资源编号，必须按编号从小到大的顺序申请资源

**缺点**：不方便增加新设备；会导致资源浪费；用户编程麻烦

#### 银行家算法

1）检查此次申请是否超过了之前声明的最大需求数

2）检查此时系统剩余的可用资源是否还能满足这次请求

3）试探着分配，更改各数据结构、

4）用安全性算法检查此次分配是否会导致系统进入不安全状态

#### 安全性算法

检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。

不断重复上述过程，看最终是否能让所有进程都加入安全序列

#### 破坏死锁

一旦检测出死锁的发生，就应该立即解除死锁

**补充**：并不是系统中所有的进程都是死锁状态，用死锁检测算法<font color=red>**化简资源分配图后，还连着边的那些进程就是死锁进程**</font>

解除死锁的主要方法有：

<font color=red>资源剥夺法</font>：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿

<font color=red>撤销进程法</font>（或称<font color=red>终止进程法</font>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来

<font color=red>进程回退法</font>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求记录进程的历史信息，设置还原点

## 内存管理

### 内存的基础知识

### **从写程序到程序运行**

#### 编译

由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言<font color=red>**翻译为机器语言**</font>）

#### 链接

由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块

##### 静态链接

##### 装入时动态链接

在程序运行前，先将各个目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）之后不再拆开

##### 运行时动态链接

将各个目标模块装入内存时，边装入边链接的链接方式

##### 运行时动态链接

在程序执行中需要该目标模块时，才对它进行链接。其有点是便于修改和更新，便于实现对目标模块的共享

#### 装入（装载）

由装入程序将装入模块装入内存运行

##### 绝对装入

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生的绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存

编译、链接后得到的装入模块的指令直接就使用了绝对地址

绝对装入只适用于<font color=red>**单道程序环境**</font>

##### 可重定位装入

<font color=red>**静态重定位**</font>，又称<font color=red>**可重定位装入**</font>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“<font color=red>**重定位**</font>”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）

静态重定位的特点是在的特点是在一个作业装入内存时，<font color=red>**必须分配器要求的全部内存空间**</font>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，<font color=red>**在运行期间就不能再移动**</font>，也不能再申请内存空间

##### 动态重定位

<font color=red>**动态重定位**</font>，又称<font color=red>**动态运行时装入**</font>。编译、链接后的装入模块的后，并不会立即把逻辑地址转换为物理地址，而是<font color=red>**把地址转换推迟到程序真正要执行时才运行**</font>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<font color=red>**重定位寄存器**</font>的支持

采用动态重定位时<font color=red>**允许程序在内存中发生移动**</font>。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配空间；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

**重定位寄存器**

存放装入模块存放的<font color=red>**起始位置**</font>

### 地址转换

操作系统作为系统资源的管理者，当然也需要对内存进行管理

操作系统负责***内存空间的分配与回收***

操作系统需要提供某种技术从逻辑上***对内存空间进行扩充***

操作系统需要提供地址转换功能，负责程序的<font color=red>**逻辑地址**</font>与<font color=red>**物理地址**</font>的转换
为了使编程更方便，程序员写程序时应该只关注指令、数据的逻辑地址。而<font color=red>逻辑地址到物理地址的转换</font>（这个过程称为<font color=red>地址重定位</font>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况

### 内存保护

内存保护可采取两种方法：

#### 方法1

在CPU中<font color=red>设置一对上、下限寄存器</font>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。

#### 方法2

采用<font color=red>重定位寄存器</font>（又称为<font color=red>基址寄存器</font>）和<font color=red>界地址寄存器</font>（又称<font color=red>限长寄存器</font>）进行越界检查。重定位寄存器中存放的是进程的<font color=red>起始物理地址</font>。界地址寄存器中存放的是进程的<font color=red>最大逻辑地址</font>

### 覆盖技术

<font color=red>覆盖技术</font>，用来<font color=red>解决“程序大小超过物理内存总和”的问题</font>

#### 覆盖技术的思想

将<font color=red>程序分为多个段</font>（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。

内存中分为<font color=red>一个“固定区”</font>和<font color=red>若干个“覆盖区”</font>

需要常驻内存的段放在<font color=red>“固定区”</font>中，<font color=red>调入后就不再调出（除非运行结束）</font>

不常用的段放在<font color=red>“覆盖区”</font>，<font color=red>需要用到时调入内存，用不到时调出内存</font>

### 交换技术

#### 交换（对换）技术的设计思想

内存空间紧张时，系统将内存中某些进程暂时<font color=red>换出</font>外存，把外存中已具备运行条件的进程<font color=red>换入</font>内存（进程在内存与磁盘间动态调度）

暂时换出外存等的进程状态为<font color=red>挂起状态（挂起态，suspend）</font>

挂起态又可以进一步细分为<font color=red>就绪挂起</font>、<font color=red>阻塞挂起</font>两种状态

## 文件管理

## 输入/输出（I/O）管理

